<?xml version="1.0" ?>
<VisualStates>
  <config type="0">
    <interfaces>
      <interface>
        <serverType>ice</serverType>
        <name>myCmdvel</name>
        <topic></topic>
        <proxyName>ardrone_cmdvel</proxyName>
        <ip>0.0.0.0</ip>
        <port>9995</port>
        <interfaceName>CMDVel</interfaceName>
      </interface>
      <interface>
        <serverType>ice</serverType>
        <name>myCamera</name>
        <topic></topic>
        <proxyName>ardrone_camera</proxyName>
        <ip>0.0.0.0</ip>
        <port>9999</port>
        <interfaceName>Camera</interfaceName>
      </interface>
      <interface>
        <serverType>ice</serverType>
        <name>myExtra</name>
        <topic></topic>
        <proxyName>ardrone_extra</proxyName>
        <ip>0.0.0.0</ip>
        <port>9994</port>
        <interfaceName>ArDroneExtra</interfaceName>
      </interface>
      <interface>
        <serverType>ice</serverType>
        <name>myPose</name>
        <topic></topic>
        <proxyName>ardrone_pose3d</proxyName>
        <ip>0.0.0.0</ip>
        <port>9998</port>
        <interfaceName>Pose3d</interfaceName>
      </interface>
    </interfaces>
  </config>
  <functions>def rollCorrection(self,t):

    if (t&gt;=0):

        t = (2*t)/(math.pi) - 1

    else:

        t = (2*t)/(math.pi) + 1

        

    return t

def pitchCorrection(self,x,th,pitch):
    if(pitch&lt;0):
        if((th-x)&lt;0):
            pitch=-pitch
    else:
        if((th-x)&gt;0):
            pitch=-pitch
    return pitch

#Checks if valid Rotation Matrix

def isRotationMatrix(self,R) :

    Rt = np.transpose(R)

    shouldBeIdentity = np.dot(Rt, R)

    I = np.identity(3, dtype = R.dtype)

    n = np.linalg.norm(I - shouldBeIdentity)

    return n &lt; 1e-6

  

#Calculates rotation matrix to euler angles

def rotationMatrixToEulerAngles(self,R) :

 

    assert(self.isRotationMatrix(R))

     

    sy = math.sqrt(R[0,0] * R[0,0] +  R[1,0] * R[1,0])

     

    singular = sy &lt; 1e-6

 

    if  not singular :

        x = math.atan2(R[2,1] , R[2,2])

        y = math.atan2(-R[2,0], sy)

        z = math.atan2(R[1,0], R[0,0])

    else :

        x = math.atan2(-R[1,2], R[1,1])

        y = math.atan2(-R[2,0], sy)

        z = 0

 

    return np.array([x, y, z])



def hsvFilter(self,hup,sup,vup,hdwn,sdwn,vdwn,img,hsv):

    if hdwn &lt;= hup:

            # http://docs.opencv.org/3.0-beta/doc/py_tutorials/py_imgproc/py_colorspaces/py_colorspaces.html

            minValues = np.array([hdwn,sdwn,vdwn],dtype=np.uint8)

            maxValues = np.array([hup,sup,vup], dtype=np.uint8)



            mask = cv2.inRange(hsv, minValues, maxValues)

            res = cv2.bitwise_and(img,img, mask= mask)

            return mask,res

    else:

        # http://docs.opencv.org/3.0-beta/doc/py_tutorials/py_imgproc/py_colorspaces/py_colorspaces.html

        # red goes from 240 to 20 degreess aprox

        maxValues1 = np.array([hup,sup,vup],dtype=np.uint8)

        minValues1 = np.array([0,sdwn,vdwn],dtype=np.uint8)

        maxValues2 = np.array([180,sup,vup], dtype=np.uint8)

        minValues2 = np.array([hdwn,sdwn,vdwn],dtype=np.uint8)



        mask1 = cv2.inRange(hsv, minValues1, maxValues1)

        mask2 = cv2.inRange(hsv, minValues2, maxValues2)

        restMask = mask1 + mask2



        r1 = cv2.bitwise_and(img,img, mask= mask1)

        r2 = cv2.bitwise_and(img,img, mask= mask2)

        res = cv2.bitwise_or(r1, r2)

        return restMask,res



def drawContours(self,contours,f):

    i=0

    areas = [cv2.contourArea(c) for c in contours]

    for extension in areas:

        #print &quot;Area: &quot;+str(extension)

        if extension &gt; self.minArea:

            img = np.zeros((self.center[0]*2,self.center[1]*2,3), np.uint8)

            actual = contours[i]

            approx = cv2.approxPolyDP(actual,0.05*cv2.arcLength(actual,True),True)

            cv2.drawContours(img,[actual],0,(0,30,0),12)            

            f.append(img)            

            i=i+1

    return f



def findCrosshair(self,input_image,maskRGBPrimary,maskRGBSecondary):

    f=[]

    i=0

    #calculating crosshair between colours

    imgray = cv2.cvtColor(maskRGBPrimary,cv2.COLOR_BGR2GRAY)

    ret,thresh = cv2.threshold(imgray,255,255,255)

    _,contours, hierarchy = cv2.findContours(thresh,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)

    #print &quot;Primary&quot;

    f = self.drawContours(contours,f)

    imgray = cv2.cvtColor(maskRGBSecondary,cv2.COLOR_BGR2GRAY)

    ret,thresh = cv2.threshold(imgray,255,255,255)

    _,contours, hierarchy = cv2.findContours(thresh,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)

    #print &quot;Secondary&quot;

    f = self.drawContours(contours,f)

    kernel = np.ones((5,5),np.uint8)

    result = input_image

    if(len(f)&gt;0):

        f[0] = cv2.dilate(f[0],kernel,iterations = 4)

        result=f[0]

        for k in range(len(f)-1):

            f[k+1] = cv2.dilate(f[k+1],kernel,iterations = 4)

            result=result+f[k+1]

    return result,f



def getCrosshairCoord(self, crosshair,image):

    centerDetectedY=0

    centerDetectedX=0

    crossYarr=[]

    crossXarr=[]

    foundCenter=False
    circleImage = image

    lower_green = np.array([0,80,0], dtype=np.uint8)

    upper_green = np.array([0, 255,0], dtype=np.uint8)

    maskSHI = cv2.inRange(crosshair, lower_green, upper_green)

    #filtering center from rest of the image

    centerImage = cv2.bitwise_and(crosshair,crosshair, mask= maskSHI)

    compare_image = np.zeros((self.center[0]*2,self.center[1]*2,3), np.uint8)

    diff = cv2.absdiff(compare_image, centerImage)

    imgray = cv2.cvtColor(diff, cv2.COLOR_BGR2GRAY)

    _,contours,_ = cv2.findContours(imgray,cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_SIMPLE)



    if(len(contours)&gt;0):

        foundCenter=True

        for c in contours:

            if(cv2.contourArea(c) &gt;= 0):

                rectY, rectX, width, height = cv2.boundingRect(c)

                cv2.rectangle(circleImage,(rectY,rectX),(rectY+width,rectX+height),(0,0,255),2)

                #calculating center of crossair

                crossY= (rectY+rectY+width)/2

                crossX= (rectX+rectX+height)/2

                #

                #img = show_image+1-1

                #radius = int(math.sqrt(((rectY+width)^2)+((rectX+height)^2)))

                #cv2.circle(circleImage,(rectY,rectX), radius, (255,255,0), 1)
				
                crossYarr.append(crossY)

                crossXarr.append(crossX)

        for values in crossYarr:

            centerDetectedY+=values

        centerDetectedY/= len(crossYarr)

        for values in crossXarr:

            centerDetectedX+=values

        centerDetectedX/= len(crossXarr)

    return centerDetectedY,centerDetectedX,foundCenter,circleImage



#Calculate PID

def getPIDSpeed(self,error,pError,vi,cycle,kp,kd,ki):
    #Proporcional
    vp = kp * error

    #Derivada

    vd = kd * ((error-pError)/cycle)

    #Integral 
    viModified = ki * (vi+(error*cycle))

    #print &quot;vp=%.4f&quot; % vp,&quot;vd=%.4f&quot; % vd,&quot;vi=%.4f&quot; % viModified

    #Total

    result = vp + vd + viModified

    return  result, viModified



def printPerformance(self,start):

    finish_Time = datetime.datetime.now()

    dt = finish_Time - start

    ms = (dt.days * 24 * 60 * 60 + dt.seconds) * 1000 + dt.microseconds / 1000.0
    if (ms&lt;self.minf):
        self.minf=ms
    if (self.maxf&lt;ms):
        self.maxf=ms
    if (self.c==0):
        self.listf[0]=ms
        self.c=1
    elif(self.c==1):
        self.listf[1]=ms
        self.c=2
    elif(self.c==2):
        self.listf[2]=ms
        self.c=0
    for x in self.listf:
        self.avgf=int(x)+self.avgf
    self.avgf=self.avgf/4    
    print &quot;Performance Monitor: %d ms&quot; % ms #Time in miliseconds
    print &quot;Min: %d &quot; % self.minf + &quot;Avg: %d &quot; % self.avgf + &quot;Max: %d &quot; % self.maxf


def limitSpeed(self,vTarget):    
    if abs(vTarget)&gt;self.maxSpeed:
        if vTarget&gt;0:
            vTarget=self.maxSpeed
        else:
            vTarget=-self.maxSpeed  
    return vTarget</functions>
  <variables>self.maxSpeed = 0.3 #Real_relativa 0.07 #Cambiar max_speed
self.cycle = 40.0 #in ms
#Transitions Variables
self.timeToLand = False
self.timeToApril = False
self.timeToColor = False
self.colorBeaconLost = False
self.colorBeaconFound = False
#Xml Files
#self.xmlFileName = 'calibration_simulated.xml'
self.xmlFileName = 'calibration.xml'
#Image Center
self.center = [0,0]
#Search
#self.numVuelta=50
#self.wSearch=0.0
#self.timerW=0.0
self.cycleCounter=0
#self.searchTrips=1
self.cyclePeriod=(1/(self.cycle/1000.0))*5 #Gets how many cycles are need per second/ Our frequency
self.xSearchSpeed=0.01
self.wSearchSpeed=0.3
#self.searchSpeed=0.01
self.searchIncrement=0.01
#Initialize
self.initialize=True
self.calibration = True
#For PIDs
'''Color Beacon Variables'''
#PID Constants
self.kpxColor = 0.0001   #RealICS #Real 0.012 #Virtual 0.005
self.kdxColor = 0.06 #0.05    #Real ICS #Real  #Virtual 0.016
self.kixColor = 0.000001 #0.000001  #Real ICS #Real #Virtual 0.00004
self.kpyColor = 0.0001   #Real ICS #Real #Virtual 0.0025
self.kdyColor = 0.05 #0.05    #Real ICS #Real #Virtual 0.008
self.kiyColor = 0.000003 #0.000001  #Real ICS #Real #Virtual 0.00006
self.kpzColor = 0        
self.kdzColor = 0        
self.kizColor = 0        
self.xDistanceDeadBand = 0.1 #Virtual 0
self.yDistanceDeadBand = 0.1 #Virtual 0
self.zDistanceDeadBand = 0 

self.errYPrevColor=0.0
self.errXPrevColor=0.0
#Color Filter
self.minArea = 700 #Gazebo 700
self.PH_max = 180
self.PS_max = 255
self.PV_max = 255
self.PH_min = 0
self.PS_min = 0
self.PV_min = 0
self.PErode = 0
self.PDilate = 0
self.SH_max = 180
self.SS_max = 255
self.SV_max = 255
self.SH_min = 0
self.SS_min = 0
self.SV_min = 0
self.SErode = 0
self.SDilate = 0
self.alpha = 0.6
self.vxiColor = 0.0
self.vyiColor = 0.0
self.vziColor = 0.0

#Stabilization checking
self.stableTime=0
self.timeLimitToLand = 2.5 #In seconds
'''Apriltag Beacon Variables'''
self.dead_band_x = 0.1 #Real_imagen #Real_pose 0.4  #Real_April 0.1 #Virtual 0.2
self.dead_band_y = 0.1 #Real_imagen #Real_pose 0.15 #Real_April 0.1 #Virtual 0.2
self.dead_band_z = 0.15 #Real_imagen #Real 0.2 #Virtual 0.2
self.min_z = 2.8       #Real 2.8
self.dead_band_w = 0.1 #Real_imagen #Real 0.180 #0.09
self.targetCenter = [0,0] #CAMBIAR
self.kp = 0.0002    #Real ICS #Real_pose 0.1 #Real_April 0.01  #Virtual 0.0025
self.kd = 0       #Real ICS #Real_pose 1500 #Real_April 5 #Virtual 0.008
self.ki = 0 #Real ICS #Real_pose #Real_April 0.003 #Virtual 0.00006
self.kpw = 0.3      #Real ICS #Real 0.1 #Virtual 0.1
self.kdw = 5        #Real ICS #Real 0 #Virtual 0
self.kiw = 0        #Real ICS #Real 0 #Virtual 0
self.kpz = 0.007    #Real ICS #Real 0.006 #Virtual 0.1
self.kdz = 1        #Real ICS #Real 1 | 0.7#Virtual 0.01
self.kiz = 0.0001  #Real ICS # Real 0.00006# Virtual 0.001
self.error_xy_anterior = [0.0,0.0]
self.error_z_anterior = 0.0
self.error_w_anterior = 0.0
self.vxi = 0
self.vyi = 0
self.vzi = 0
self.vwi = 0
#AprilTags
self.options = apriltag.DetectorOptions()
self.detector = apriltag.Detector(self.options)
#Marker Size
self.MARKER_SIZE = 0.28 #Size in meters
self.m_MarkerPoints = np.zeros((4,3),dtype=np.float32)
#Image Processing
#self.cameraMatrix = np.resize(np.array([187.336, 0, 160, 0, 187.336, 120, 0, 0, 1]),(3,3)) #Gazebo simulator
self.cameraMatrix = np.resize(np.array([731.37257937739332, 0, 322.35647387552422, 0, 734.23757205576192, 246.30430666269825, 0, 0, 1]),(3,3)) #ArDrone 2
#Distorsion Coefficients
#self.distCoeffs = np.zeros((5, 1), np.uint8) #Gazebo
self.distCoeffs = np.array([-0.07304604105914128, 0.50646907582979650, 0.00024443957708413687, 0.00074556540195940392,-1.0762308065763191]) #ArDrone 2
#Pose
self.x = 0.0
self.y = 0.0
self.z = 0.0
self.pitch = 0.0
#Beacons
self.beacons = [4,7,16,30]
self.beaconCounter = 0
self.switchBeacon = False
self.timeOnTarget=0.0
self.timeLimitToChange = 10 #In seconds
'''Performance monitor variables'''
#Performance monitor
self.minf = 10000
self.maxf = 0
self.avgf = 0
self.listf = [0,0,0]
self.c = 0</variables>
  <libraries>
    <library>cv2</library>
    <library>numpy as np</library>
    <library>apriltag</library>
    <library>math</library>
    <library>xml.etree.ElementTree as ET</library>
    <library>time</library>
    <library>datetime</library>
    <library>traceback</library>
    <library>logging</library>
  </libraries>
  <state id="0" initial="True">
    <posx>0.0</posx>
    <posy>0.0</posy>
    <name>root</name>
    <code></code>
    <timestep>40</timestep>
    <state id="1" initial="False">
      <posx>841.0</posx>
      <posy>1208.0</posy>
      <name>April Beacon Tracking</name>
      <code>logging.basicConfig(filename='April',format='%(asctime)s %(message)s',level=logging.INFO,filemode='w')
start_time = datetime.datetime.now()

vx=0
vy=0
vz=0
vw=0
error_xy = [0,0]
error_z = 0
error_w = 0
onTarget=False

#Image Processing
inputImage = self.interfaces.myCamera.getImage()
inputImageData = inputImage.data
inputImageData_h = inputImage.height
inputImageData_w = inputImage.width
inputImageData.shape = inputImageData_h, inputImageData_w, 3
color = cv2.cvtColor(inputImageData, cv2.COLOR_RGB2BGR)
#Apriltags Detection
gray = cv2.cvtColor(inputImageData, cv2.COLOR_RGB2GRAY)
#cv2.imshow(&quot;Image&quot;,gray)
#cv2.waitKey(30)
detections = self.interfaces.detector.detect(gray)
num_detections = len(detections)
if (num_detections &lt;= 0):
    self.interfaces.x = 0.0
    self.interfaces.y = 0.0
    self.interfaces.z = 0.0
    self.interfaces.pitch = 0.0
else:
    for i,detection in enumerate(detections):
        if (detection.tag_id == self.interfaces.beacons[self.interfaces.beaconCounter]):
            onTarget=True
            #print &quot;Beacon %d detected&quot; % detection.tag_id
            retVal,rvec,tvec =cv2.solvePnP(self.interfaces.m_MarkerPoints
                                        ,detection.corners
                                        ,self.interfaces.cameraMatrix
                                        ,self.interfaces.distCoeffs)
            rodri = cv2.Rodrigues(rvec)
            #We get X,Y and Z
            cameraPosition = -np.matrix(rodri[0]).T * np.matrix(tvec) 
            self.interfaces.x = detection.center[0]
            self.interfaces.y = detection.center[1]
            #xApril = detection.center[0]
            #yApril = detection.center[1]
            #self.interfaces.x = cameraPosition.item(0) #Center needs to be changed
            #self.interfaces.y = cameraPosition.item(1) #Center needs to be changed
            self.interfaces.z = cameraPosition.item(2)
            #We get roll, pitch and yaw from Euler Angles        
            eulerAngles = self.interfaces.rotationMatrixToEulerAngles(rodri[0])
            #yaw = eulerAngles[0]
            #pitch = eulerAngles[1]
            #roll = self.interfaces.rollCorrection(eulerAngles[2])
            #Threshold for pitch correction (center of the width of the image)
            th=inputImageData_w/2
            self.interfaces.pitch = self.interfaces.pitchCorrection(self.interfaces.x,th,eulerAngles.item(1))
            #self.interfaces.pitch = self.interfaces.pitchCorrection(xApril,th,eulerAngles.item(1)) #POSE
            #print xApril, yApril, self.interfaces.pitch
        
            logging.info (&quot;1-x %.3f;&quot; % self.interfaces.x + &quot;y %.3f;&quot; % self.interfaces.y + &quot;z %.3f;&quot; % self.interfaces.z + &quot;pitch %.3f&quot; % self.interfaces.pitch)
            if (abs(self.interfaces.x)&gt;0 or abs(self.interfaces.y)&gt;0 or abs(self.interfaces.z)&gt;0 or abs(self.interfaces.pitch)&gt;0):
                #PID controller
                error_xy = [self.interfaces.center[0]-self.interfaces.x, self.interfaces.center[1]-self.interfaces.y]
                error_z = self.interfaces.min_z - self.interfaces.z
                error_w = -self.interfaces.pitch
                #print (&quot;error_x %.4f&quot; % error_xy[0],&quot;error_y %.4f&quot; % error_xy[1], &quot;error_z %.4f&quot; % error_z,&quot;error_pitch %.4f&quot; % error_w)
                #VX
                #print &quot;vx&quot;
                if(abs(error_xy[0])&lt;self.interfaces.dead_band_x):
                    #print &quot;Vy en banda de seguridad&quot;
                    vx=0
                    #self.yDeadZone=True
                else:
                    #Get vy Speed thanks to the PID controller and checks if in Dead band.
                    vx,vxiMod = self.interfaces.getPIDSpeed(error_xy[0]
                                                    ,self.interfaces.error_xy_anterior[0]
                                                    ,self.interfaces.vxi
                                                    ,self.interfaces.cycle
                                                    ,self.interfaces.kp
                                                    ,self.interfaces.kd
                                                    ,self.interfaces.ki)
                    self.interfaces.vxi=vxiMod
                #vy
                #print &quot;vy&quot;
                if(abs(error_xy[1])&lt;self.interfaces.dead_band_y):
                    #print &quot;Vy en banda de seguridad&quot;
                    vy=0
                    #self.yDeadZone=True
                else:
                    #Get vy Speed thanks to the PID controller and checks if in Dead band.
                    vy,vyiMod = self.interfaces.getPIDSpeed(error_xy[1]
                                                    ,self.interfaces.error_xy_anterior[1]
                                                    ,self.interfaces.vyi
                                                    ,self.interfaces.cycle
                                                    ,self.interfaces.kp
                                                    ,self.interfaces.kd
                                                    ,self.interfaces.ki)
                    self.interfaces.vyi=vyiMod
                #vz
                #print &quot;vz&quot;
                if(abs(error_z)&lt;self.interfaces.dead_band_z):
                    #print &quot;vz en banda de seguridad&quot;
                    vz=0
                    #self.yDeadZone=True
                else:
                    #Get vz Speed thanks to the PID controller and checks if in Dead band.
                    vz,vziMod = self.interfaces.getPIDSpeed(error_z
                                                    ,self.interfaces.error_z_anterior
                                                    ,self.interfaces.vzi
                                                    ,self.interfaces.cycle
                                                    ,self.interfaces.kpz
                                                    ,self.interfaces.kdz
                                                    ,self.interfaces.kiz)
                    self.interfaces.vzi=vziMod
                #vw
                #print &quot;vw&quot;
                if(abs(error_z)&lt;self.interfaces.dead_band_w):
                    #print &quot;vw en banda de seguridad&quot;
                    vw=0
                    #self.yDeadZone=True
                else:
                    #Get vw Speed thanks to the PID controller and checks if in Dead band.
                    vw,vwiMod = self.interfaces.getPIDSpeed(error_w
                                                    ,self.interfaces.error_w_anterior
                                                    ,self.interfaces.vwi
                                                    ,self.interfaces.cycle
                                                    ,self.interfaces.kpw
                                                    ,self.interfaces.kdw
                                                    ,self.interfaces.kiw)
                    self.interfaces.vwi=vwiMod   
                    
        
vy=self.interfaces.limitSpeed(vy)
vx=self.interfaces.limitSpeed(vx)
vz=self.interfaces.limitSpeed(vz)
vw=self.interfaces.limitSpeed(vw)
#Print Speeds
#logging.info (&quot;2-vz:%.3f;&quot; % -vz + &quot;vx:%.3f;&quot; % -vx+  &quot;vy:%.3f;&quot; % vy +&quot;vw:%.3f&quot; % vw) #Pose
logging.info (&quot;2-vz:%.3f;&quot; % -vz + &quot;vy:%.3f;&quot; % vy + &quot;vx:%.3f;&quot; % vx +&quot;vw:%.3f&quot; % vw) #AprilTags
#print (&quot;2-vz:%.3f;&quot; % -vz + &quot;vx:%.3f;&quot; % -vx+  &quot;vy:%.3f;&quot; % vy +&quot;vw:%.3f&quot; % vw)        #Pose
#print (&quot;2-vz:%.3f;&quot; % -vz + &quot;vx:%.3f;&quot; % vx + &quot;vy:%.3f;&quot; % vy +&quot;vw:%.3f&quot; % vw)      #AprilTags
#Send Speeds
#self.interfaces.myCmdvel.sendCMDVel(-vz,-vx,vy,0,0,vw) #Center from pose
self.interfaces.myCmdvel.sendCMDVel(-vz, vx,vy,0,0,vw)  #Center from Apriltags
self.interfaces.error_xy_anterior = error_xy
self.interfaces.error_z_anterior = error_z
self.interfaces.error_w_anterior = error_w
if (onTarget):
    diff=time.time()-self.interfaces.timeOnTarget
    if (self.interfaces.timeOnTarget==0):
        self.interfaces.timeOnTarget=time.time()
    elif (diff&lt;self.interfaces.timeLimitToChange):
        print &quot;On target for: &quot;+str(diff)+&quot; seconds&quot;
    elif (diff&gt;=self.interfaces.timeLimitToChange):
       #print &quot;Changing State&quot;
       self.interfaces.beaconCounter += 1
       self.interfaces.switchBeacon = True 
else:
    self.interfaces.timeOnTarget=0

self.interfaces.printPerformance(start_time)</code>
      <timestep>100</timestep>
      <transition id="28">
        <type>1</type>
        <condition>return self.interfaces.switchBeacon</condition>
        <posx>957.5</posx>
        <posy>1088.0</posy>
        <name>Next April Beacon</name>
        <originid>1</originid>
        <destinationid>3</destinationid>
        <code>logging.basicConfig(filename='april_performance',format='%(asctime)s %(message)s',level=logging.INFO)
logging.info(str(self.interfaces.minf) + &quot;;&quot; + str(self.interfaces.avgf) +&quot;;&quot; + str(self.interfaces.maxf))
self.interfaces.switchBeacon=False
self.interfaces.timeOnTarget=0</code>
      </transition>
    </state>
    <state id="3" initial="False">
      <posx>846.0</posx>
      <posy>974.0</posy>
      <name>AprilTag Rotational Search</name>
      <code>if self.interfaces.beaconCounter &gt;= (len(self.interfaces.beacons)):
    #All beacon accomplished
    self.interfaces.timeToColor = True
else:
    self.interfaces.myCmdvel.sendCMDVel(0,0,0,0,0,-0.2)
    inputImage = self.interfaces.myCamera.getImage()
    inputImageData = inputImage.data
    inputImageData_h = inputImage.height
    inputImageData_w = inputImage.width
    inputImageData.shape = inputImageData_h, inputImageData_w, 3
    color = cv2.cvtColor(inputImageData, cv2.COLOR_RGB2BGR)
#Apriltags Detection
    gray = cv2.cvtColor(inputImageData, cv2.COLOR_RGB2GRAY)
    detections = self.interfaces.detector.detect(gray)
    num_detections = len(detections)
    for i, detection in enumerate(detections):
        if (detection.tag_id == self.interfaces.beacons[self.interfaces.beaconCounter]):
            self.interfaces.myCmdvel.sendCMDVel(0,0,0,0,0,0)
            self.interfaces.switchBeacon=True</code>
      <timestep>100</timestep>
      <transition id="11">
        <type>1</type>
        <condition>return self.interfaces.switchBeacon</condition>
        <posx>844.0</posx>
        <posy>1087.5</posy>
        <name>Beacon Found</name>
        <originid>3</originid>
        <destinationid>1</destinationid>
        <code>self.interfaces.switchBeacon=False</code>
      </transition>
      <transition id="19">
        <type>1</type>
        <condition>return self.interfaces.timeToColor</condition>
        <posx>1002.5</posx>
        <posy>974.5</posy>
        <name>Color Beacon Search</name>
        <originid>3</originid>
        <destinationid>21</destinationid>
        <code>self.interfaces.myExtra.toggleCam()
input_image = self.interfaces.myCamera.getImage()
self.interfaces.center[0] = input_image.height/2 #X axis
self.interfaces.center[1] = input_image.width/2  #Y axis
self.interfaces.minf = 10000
self.interfaces.maxf = 0
self.interfaces.avgf = 0
self.interfaces.listf = [0,0,0]
self.interfaces.c = 0</code>
      </transition>
    </state>
    <state id="4" initial="False">
      <posx>1155.0</posx>
      <posy>1213.0</posy>
      <name>Land</name>
      <code>if(self.interfaces.timeToLand):
	self.interfaces.myExtra.land()
	self.interfaces.timeToLand=False
	print &quot;Landed - End of exercise&quot;
else:
	pass</code>
      <timestep>100</timestep>
    </state>
    <state id="12" initial="False">
      <posx>846.0</posx>
      <posy>857.0</posy>
      <name>Color Beacon Tracking</name>
      <code>logging.basicConfig(filename='color1',format='%(asctime)s %(message)s',level=logging.INFO,filemode='w')
start_time = datetime.datetime.now()

vx=0
vy=0
xError=0
yError=0
foundCenter=False
#Image Processing
input_image = self.interfaces.myCamera.getImage()
input_imageData = input_image.data
centerImage = input_imageData
hsv = cv2.cvtColor(input_imageData, cv2.COLOR_BGR2HSV)
maskPrimary,maskRGBPrimary = self.interfaces.hsvFilter(self.interfaces.PH_max,self.interfaces.PS_max,self.interfaces.PV_max,self.interfaces.PH_min,self.interfaces.PS_min,self.interfaces.PV_min,input_image.data,hsv)

maskSecondary,maskRGBSecondary = self.interfaces.hsvFilter(self.interfaces.SH_max,self.interfaces.SS_max,self.interfaces.SV_max,self.interfaces.SH_min,self.interfaces.SS_min,self.interfaces.SV_min,input_image.data,hsv)

kernel = np.ones((3,3),np.uint8)

maskRGBPrimary = cv2.erode(maskRGBPrimary,kernel,iterations = self.interfaces.PErode)
maskRGBPrimary = cv2.dilate(maskRGBPrimary,kernel,iterations = self.interfaces.PDilate)
momentsPrimary = cv2.moments(maskPrimary)
areaPrimary = momentsPrimary['m00']

maskRGBSecondary = cv2.erode(maskRGBSecondary,kernel,iterations = self.interfaces.SErode)
maskRGBSecondary = cv2.dilate(maskRGBSecondary,kernel,iterations = self.interfaces.SDilate)
momentsSecondary = cv2.moments(maskSecondary)
areaSecondary = momentsSecondary['m00']

maskRGBTot = maskRGBPrimary+maskRGBSecondary

#Controller based on how many tiles have been detected
if(areaPrimary&gt;0 and areaSecondary&gt;0):
    #print &quot;Both colors detected&quot;
    crosshair,f = self.interfaces.findCrosshair(input_imageData,maskRGBPrimary,maskRGBSecondary)
    #print &quot;F: %d&quot; % len(f)
    #f represents the number of cuadrants detected
    if(len(f)&gt;0):
        #Returns Center of crossair and checks if the center of the crossair was found.        
        crossY,crossX,foundCenter,centerImage = self.interfaces.getCrosshairCoord(crosshair,centerImage)
        logging.info(&quot;y:%.2f;&quot;% crossY + &quot;x:%.2f&quot; % crossX)
        if(foundCenter):
            #print &quot;Center Found!&quot;
            yError=self.interfaces.center[1]-crossY
            xError=self.interfaces.center[0]-crossX
            #print yError, xError 
            #Y Controller
            if(abs(yError)&lt;self.interfaces.yDistanceDeadBand):
                #print &quot;Vy en banda de seguridad&quot;
                vy=0
                #self.yDeadZone=True
            else:
                #print &quot;vy&quot;
                #Get vy Speed thanks to the PID controller and checks if in Dead band.
                vy,vyiMod = self.interfaces.getPIDSpeed(yError
                                                ,self.interfaces.errYPrevColor
                                                ,self.interfaces.vyi
                                                ,self.interfaces.cycle
                                                ,self.interfaces.kpyColor
                                                ,self.interfaces.kdyColor
                                                ,self.interfaces.kiyColor)
                self.interfaces.vyi=vyiMod
            #X Controller
            #print &quot;vx&quot;
            if(abs(xError)&lt;self.interfaces.xDistanceDeadBand):
                #print &quot;vx en banda de seguridad&quot;
                vx=0
                #self.yDeadZone=True
            else:
                #Get vx Speed thanks to the PID controller and checks if in Dead band.
                vx,vxiMod = self.interfaces.getPIDSpeed(xError
                                                ,self.interfaces.errXPrevColor
                                                ,self.interfaces.vxi
                                                ,self.interfaces.cycle
                                                ,self.interfaces.kpxColor
                                                ,self.interfaces.kdxColor
                                                ,self.interfaces.kixColor)
                self.interfaces.vxi=vxiMod
        else:
            centerImage=input_imageData
            momentsCombined = cv2.moments(maskPrimary+maskSecondary)
            if(momentsCombined['m00']&gt;0):
                yCombined = momentsCombined['m10']/momentsCombined['m00']
                xCombined = momentsCombined['m01']/momentsCombined['m00']
                yError = self.interfaces.center[1]-yCombined
                xError = self.interfaces.center[0]-xCombined
                #Y Controller
                #print &quot;vy&quot;
                vy,vyiMod = self.interfaces.getPIDSpeed(yError
                                                ,self.interfaces.errYPrevColor
                                                ,self.interfaces.vyi
                                                ,self.interfaces.cycle
                                                ,self.interfaces.kpyColor
                                                ,self.interfaces.kdyColor
                                                ,self.interfaces.kiyColor)
                self.interfaces.vyi=vyiMod
                #X Controller
                #print &quot;vx&quot;
                #Get vx Speed thanks to the PID controller and checks if in Dead band.
                vx,vxiMod = self.interfaces.getPIDSpeed(xError
                                                ,self.interfaces.errXPrevColor
                                                ,self.interfaces.vxi
                                                ,self.interfaces.cycle
                                                ,self.interfaces.kpxColor
                                                ,self.interfaces.kdxColor
                                                ,self.interfaces.kixColor)
                self.interfaces.vxi=vxiMod
elif(areaPrimary&gt;0 and areaSecondary==0):
    #print &quot;Only Primary&quot;
    yPrimary = momentsPrimary['m10']/momentsPrimary['m00']
    xPrimary = momentsPrimary['m01']/momentsPrimary['m00']
    yError = self.interfaces.center[1]-yPrimary
    xError = self.interfaces.center[0]-xPrimary
    #print yError, xError
    #Y Controller
    #print &quot;vy&quot;
    #Get vy Speed thanks to the PID controller and checks if in Dead band.
    vy,vyiMod = self.interfaces.getPIDSpeed(yError
                                    ,self.interfaces.errYPrevColor
                                    ,self.interfaces.vyi
                                    ,self.interfaces.cycle
                                    ,self.interfaces.kpyColor
                                    ,self.interfaces.kdyColor
                                    ,self.interfaces.kiyColor)
    self.interfaces.vyi=vyiMod
    #X Controller
    #Get vx Speed thanks to the PID controller and checks if in Dead band.
    vx,vxiMod = self.interfaces.getPIDSpeed(xError
                                    ,self.interfaces.errXPrevColor
                                    ,self.interfaces.vxi
                                    ,self.interfaces.cycle
                                    ,self.interfaces.kpxColor
                                    ,self.interfaces.kdxColor
                                    ,self.interfaces.kixColor)
    self.interfaces.vxi=vxiMod
elif(areaPrimary==0 and areaSecondary&gt;0):
    #print &quot;Only Secondary&quot;
    ySecondary = momentsSecondary['m10']/momentsSecondary['m00']
    xSecondary = momentsSecondary['m01']/momentsSecondary['m00']
    yError = self.interfaces.center[1]-ySecondary
    xError = self.interfaces.center[0]-xSecondary
    #print yError, xError
    #Y Controller
    #print &quot;vy&quot;
    #Get vy Speed thanks to the PID controller and checks if in Dead band.
    vy,vyiMod = self.interfaces.getPIDSpeed(yError
                                    ,self.interfaces.errYPrevColor
                                    ,self.interfaces.vyi
                                    ,self.interfaces.cycle
                                    ,self.interfaces.kpyColor
                                    ,self.interfaces.kdyColor
                                    ,self.interfaces.kiyColor)
    self.interfaces.vyi=vyiMod
    #X Controller
    #print &quot;vx&quot;
    #Get vx Speed thanks to the PID controller and checks if in Dead band.
    vx,vxiMod = self.interfaces.getPIDSpeed(xError
                                    ,self.interfaces.errXPrevColor
                                    ,self.interfaces.vxi
                                    ,self.interfaces.cycle
                                    ,self.interfaces.kpxColor
                                    ,self.interfaces.kdxColor
                                    ,self.interfaces.kixColor)
    self.interfaces.vxi=vxiMod                                
#else:
   #print &quot;Color Beacon not found&quot;

#Function in order to check if the tracking is stable on the center
if (foundCenter):
    diff=time.time()-self.interfaces.stableTime
    if (self.interfaces.stableTime==0):
        self.interfaces.stableTime=time.time()
    elif (diff&lt;self.interfaces.timeLimitToLand):
        print &quot;On target for: &quot;+str(diff)+&quot; seconds&quot;
    elif (diff&gt;=self.interfaces.timeLimitToLand):
        #print &quot;Changing State&quot;
        self.interfaces.timeToApril=True   
else:
    self.interfaces.stableTime=0
#Limiting the speed prevents from overshooting as a failsafe    
vy=self.interfaces.limitSpeed(vy)
vx=self.interfaces.limitSpeed(vx)            
#Send orders to ArDrone 2                    
logging.info(&quot;vx=%.4f;&quot; % vx + &quot;vy=%.4f&quot; % vy)
self.interfaces.myCmdvel.sendCMDVel(vx,vy,0,0,0,0) 
self.interfaces.errXPrevColor=xError
self.interfaces.errYPrevColor=yError           

self.interfaces.printPerformance(start_time)

#End Takeoff</code>
      <timestep>100</timestep>
      <transition id="14">
        <type>1</type>
        <condition>return self.interfaces.timeToApril</condition>
        <posx>845.5</posx>
        <posy>911.5</posy>
        <name>Stable on Color Beacon</name>
        <originid>12</originid>
        <destinationid>3</destinationid>
        <code>logging.basicConfig(filename='color1_performance',format='%(asctime)s %(message)s',level=logging.INFO)
logging.info(str(self.interfaces.minf) + &quot;;&quot; + str(self.interfaces.avgf) +&quot;;&quot; + str(self.interfaces.maxf))
self.interfaces.myExtra.toggleCam()
input_image = self.interfaces.myCamera.getImage()
self.interfaces.center[1] = input_image.height/2 #X axis
self.interfaces.center[0] = input_image.width/2  #Y axis
#self.interfaces.center=[0,0] #Comment this line if using Apriltags
self.interfaces.minf = 10000
self.interfaces.maxf = 0
self.interfaces.avgf = 0
self.interfaces.listf = [0,0,0]
self.interfaces.c = 0</code>
      </transition>
    </state>
    <state id="20" initial="False">
      <posx>846.0</posx>
      <posy>732.0</posy>
      <name>Initialization</name>
      <code>if(self.interfaces.calibration):
    #Color beacon initialization
    tree = ET.parse(self.interfaces.xmlFileName)
    root = tree.getroot()
    for colour in root.findall('colour'):
        name = colour.get('name')
        if (name==&quot;Primary&quot;):
            self.interfaces.PH_max = int(colour.find('Hmax').text)
            self.interfaces.PS_max = int(colour.find('Smax').text)
            self.interfaces.PV_max = int(colour.find('Vmax').text)
            self.interfaces.PH_min = int(colour.find('Hmin').text)
            self.interfaces.PS_min = int(colour.find('Smin').text)
            self.interfaces.PV_min = int(colour.find('Vmin').text)
            self.interfaces.PErode = int(colour.find('Erosion').text)
            self.interfaces.PDilate = int(colour.find('Dilation').text)

        elif(name==&quot;Secondary&quot;):
            self.interfaces.SH_max = int(colour.find('Hmax').text)
            self.interfaces.SS_max = int(colour.find('Smax').text)
            self.interfaces.SV_max = int(colour.find('Vmax').text)
            self.interfaces.SH_min = int(colour.find('Hmin').text)
            self.interfaces.SS_min = int(colour.find('Smin').text)
            self.interfaces.SV_min = int(colour.find('Vmin').text)
            self.interfaces.SErode = int(colour.find('Erosion').text)
            self.interfaces.SDilate = int(colour.find('Dilation').text)
    #Apriltags Initialization
    HALF_MARKER_SIZE=self.interfaces.MARKER_SIZE/2 
    self.interfaces.m_MarkerPoints[0,0] =-HALF_MARKER_SIZE
    self.interfaces.m_MarkerPoints[0,1] = HALF_MARKER_SIZE
    self.interfaces.m_MarkerPoints[0,2] = 0
    self.interfaces.m_MarkerPoints[1,0] = HALF_MARKER_SIZE
    self.interfaces.m_MarkerPoints[1,1] = HALF_MARKER_SIZE
    self.interfaces.m_MarkerPoints[1,2] = 0
    self.interfaces.m_MarkerPoints[2,0] = HALF_MARKER_SIZE
    self.interfaces.m_MarkerPoints[2,1] =-HALF_MARKER_SIZE
    self.interfaces.m_MarkerPoints[2,2] = 0
    self.interfaces.m_MarkerPoints[3,0] = -HALF_MARKER_SIZE
    self.interfaces.m_MarkerPoints[3,1] = -HALF_MARKER_SIZE
    self.interfaces.m_MarkerPoints[3,2] = 0
    #self.interfaces.cameraMatrix =  np.resize(self.interfaces.cameraMatrix,3,3)
    self.interfaces.calibration = False
	
    print &quot;calibration from file &quot;+ self.interfaces.xmlFileName + &quot; completed&quot;

if(self.interfaces.initialize):
    input_image = self.interfaces.myCamera.getImage()
    self.interfaces.initialize=False #Cambiar
    self.interfaces.center[0] = input_image.height/2 #X axis
    self.interfaces.center[1] = input_image.width/2  #Y axis
    self.interfaces.initialize = False
#Ready to Take Off
</code>
      <timestep>100</timestep>
      <transition id="16">
        <type>0</type>
        <time>1000</time>
        <posx>846.5</posx>
        <posy>788.0</posy>
        <name>Controlled Take Off</name>
        <originid>20</originid>
        <destinationid>12</destinationid>
        <code></code>
      </transition>
    </state>
    <state id="21" initial="False">
      <posx>1158.0</posx>
      <posy>971.0</posy>
      <name>Spiral Search</name>
      <code>xSpeed=0
wSpeed=0

input_image = self.interfaces.myCamera.getImage()
input_imageData = input_image.data
centerImage = input_imageData
hsv = cv2.cvtColor(input_imageData, cv2.COLOR_BGR2HSV)
maskPrimary,maskRGBPrimary = self.interfaces.hsvFilter(self.interfaces.PH_max,self.interfaces.PS_max,self.interfaces.PV_max,self.interfaces.PH_min,self.interfaces.PS_min,self.interfaces.PV_min,input_image.data,hsv)

maskSecondary,maskRGBSecondary = self.interfaces.hsvFilter(self.interfaces.SH_max,self.interfaces.SS_max,self.interfaces.SV_max,self.interfaces.SH_min,self.interfaces.SS_min,self.interfaces.SV_min,input_image.data,hsv)

kernel = np.ones((3,3),np.uint8)

maskRGBPrimary = cv2.erode(maskRGBPrimary,kernel,iterations = self.interfaces.PErode)
maskRGBPrimary = cv2.dilate(maskRGBPrimary,kernel,iterations = self.interfaces.PDilate)
momentsPrimary = cv2.moments(maskPrimary)
areaPrimary = momentsPrimary['m00']

maskRGBSecondary = cv2.erode(maskRGBSecondary,kernel,iterations = self.interfaces.SErode)
maskRGBSecondary = cv2.dilate(maskRGBSecondary,kernel,iterations = self.interfaces.SDilate)
momentsSecondary = cv2.moments(maskSecondary)
areaSecondary = momentsSecondary['m00']


if(areaPrimary&gt;0 or areaSecondary&gt;0):
    self.interfaces.colorBeaconFound=True
    self.interfaces.myCmdvel.sendCMDVel(0,0,0,0,0,0)
    self.interfaces.myCmdvel.sendCMDVel(0,0,0,0,0,0)
    self.interfaces.myCmdvel.sendCMDVel(0,0,0,0,0,0)
else:
    if(self.interfaces.cycleCounter&gt;self.interfaces.cyclePeriod):
        self.interfaces.cycleCounter=0
        self.interfaces.xSearchSpeed+=self.interfaces.searchIncrement
        
    xSpeed=-self.interfaces.xSearchSpeed
    wSpeed=self.interfaces.wSearchSpeed        
    self.interfaces.cycleCounter+=1
    
self.interfaces.myCmdvel.sendCMDVel(-xSpeed,0,0,0,0,wSpeed)</code>
      <timestep>100</timestep>
      <transition id="22">
        <type>1</type>
        <condition>return self.interfaces.colorBeaconFound</condition>
        <posx>1204.5</posx>
        <posy>1030.5</posy>
        <name>Found</name>
        <originid>21</originid>
        <destinationid>23</destinationid>
        <code>self.interfaces.colorBeaconFound=False</code>
      </transition>
    </state>
    <state id="23" initial="False">
      <posx>1154.0</posx>
      <posy>1089.0</posy>
      <name>Color Beacon Landing</name>
      <code>logging.basicConfig(filename='color1',format='%(asctime)s %(message)s',level=logging.INFO,filemode='w')
start_time = datetime.datetime.now()

vx=0
vy=0
xError=0
yError=0
foundCenter=False
#Image Processing
input_image = self.interfaces.myCamera.getImage()
input_imageData = input_image.data
centerImage = input_imageData
hsv = cv2.cvtColor(input_imageData, cv2.COLOR_BGR2HSV)
maskPrimary,maskRGBPrimary = self.interfaces.hsvFilter(self.interfaces.PH_max,self.interfaces.PS_max,self.interfaces.PV_max,self.interfaces.PH_min,self.interfaces.PS_min,self.interfaces.PV_min,input_image.data,hsv)

maskSecondary,maskRGBSecondary = self.interfaces.hsvFilter(self.interfaces.SH_max,self.interfaces.SS_max,self.interfaces.SV_max,self.interfaces.SH_min,self.interfaces.SS_min,self.interfaces.SV_min,input_image.data,hsv)

kernel = np.ones((3,3),np.uint8)

maskRGBPrimary = cv2.erode(maskRGBPrimary,kernel,iterations = self.interfaces.PErode)
maskRGBPrimary = cv2.dilate(maskRGBPrimary,kernel,iterations = self.interfaces.PDilate)
momentsPrimary = cv2.moments(maskPrimary)
areaPrimary = momentsPrimary['m00']

maskRGBSecondary = cv2.erode(maskRGBSecondary,kernel,iterations = self.interfaces.SErode)
maskRGBSecondary = cv2.dilate(maskRGBSecondary,kernel,iterations = self.interfaces.SDilate)
momentsSecondary = cv2.moments(maskSecondary)
areaSecondary = momentsSecondary['m00']

maskRGBTot = maskRGBPrimary+maskRGBSecondary

#Controller based on how many tiles have been detected
if(areaPrimary&gt;0 and areaSecondary&gt;0):
    #print &quot;Both colors detected&quot;
    crosshair,f = self.interfaces.findCrosshair(input_imageData,maskRGBPrimary,maskRGBSecondary)
    #print &quot;F: %d&quot; % len(f)
    #f represents the number of cuadrants detected
    if(len(f)&gt;0):
        #Returns Center of crossair and checks if the center of the crossair was found.        
        crossY,crossX,foundCenter,centerImage = self.interfaces.getCrosshairCoord(crosshair,centerImage)
        logging.info(&quot;y:%.2f;&quot;% crossY + &quot;x:%.2f&quot; % crossX)
        if(foundCenter):
            #print &quot;Center Found!&quot;
            yError=self.interfaces.center[1]-crossY
            xError=self.interfaces.center[0]-crossX 
            #Y Controller
            if(abs(yError)&lt;self.interfaces.yDistanceDeadBand):
                #print &quot;Vy en banda de seguridad&quot;
                vy=0
                #self.yDeadZone=True
            else:
                #print &quot;vy&quot;
                #Get vy Speed thanks to the PID controller and checks if in Dead band.
                vy,vyiMod = self.interfaces.getPIDSpeed(yError
                                                ,self.interfaces.errYPrevColor
                                                ,self.interfaces.vyi
                                                ,self.interfaces.cycle
                                                ,self.interfaces.kpyColor
                                                ,self.interfaces.kdyColor
                                                ,self.interfaces.kiyColor)
                self.interfaces.vyi=vyiMod
            #X Controller
            #print &quot;vx&quot;
            if(abs(xError)&lt;self.interfaces.xDistanceDeadBand):
                #print &quot;vx en banda de seguridad&quot;
                vx=0
                #self.yDeadZone=True
            else:
                #Get vx Speed thanks to the PID controller and checks if in Dead band.
                vx,vxiMod = self.interfaces.getPIDSpeed(xError
                                                ,self.interfaces.errXPrevColor
                                                ,self.interfaces.vxi
                                                ,self.interfaces.cycle
                                                ,self.interfaces.kpxColor
                                                ,self.interfaces.kdxColor
                                                ,self.interfaces.kixColor)
                self.interfaces.vxi=vxiMod
        else:
            centerImage=input_imageData
            momentsCombined = cv2.moments(maskPrimary+maskSecondary)
            if(momentsCombined['m00']&gt;0):
                yCombined = momentsCombined['m10']/momentsCombined['m00']
                xCombined = momentsCombined['m01']/momentsCombined['m00']
                yError = self.interfaces.center[1]-yCombined
                xError = self.interfaces.center[0]-xCombined
                #Y Controller
                #print &quot;vy&quot;
                if(abs(yError)&lt;self.interfaces.yDistanceDeadBand):
                    #print &quot;Vy en banda de seguridad&quot;
                    vy=0
                    #self.yDeadZone=True
                else:
                    #Get vy Speed thanks to the PID controller and checks if in Dead band.
                    vy,vyiMod = self.interfaces.getPIDSpeed(yError
                                                    ,self.interfaces.errYPrevColor
                                                    ,self.interfaces.vyi
                                                    ,self.interfaces.cycle
                                                    ,self.interfaces.kpyColor
                                                    ,self.interfaces.kdyColor
                                                    ,self.interfaces.kiyColor)
                    self.interfaces.vyi=vyiMod
                #X Controller
                #print &quot;vx&quot;
                if(abs(xError)&lt;self.interfaces.xDistanceDeadBand):
                    #print &quot;vx en banda de seguridad&quot;
                    vx=0
                    #self.yDeadZone=True
                else:
                    #Get vx Speed thanks to the PID controller and checks if in Dead band.
                    vx,vxiMod = self.interfaces.getPIDSpeed(xError
                                                    ,self.interfaces.errXPrevColor
                                                    ,self.interfaces.vxi
                                                    ,self.interfaces.cycle
                                                    ,self.interfaces.kpxColor
                                                    ,self.interfaces.kdxColor
                                                    ,self.interfaces.kixColor)
                    self.interfaces.vxi=vxiMod
elif(areaPrimary&gt;0 and areaSecondary==0):
    #print &quot;Only Primary&quot;
    yPrimary = momentsPrimary['m10']/momentsPrimary['m00']
    xPrimary = momentsPrimary['m01']/momentsPrimary['m00']
    yError = self.interfaces.center[1]-yPrimary
    xError = self.interfaces.center[0]-xPrimary
    #Y Controller
    #print &quot;vy&quot;
    if(abs(yError)&lt;self.interfaces.yDistanceDeadBand):
        #print &quot;Vy en banda de seguridad&quot;
        vy=0
        #self.yDeadZone=True
    else:
        #Get vy Speed thanks to the PID controller and checks if in Dead band.
        vy,vyiMod = self.interfaces.getPIDSpeed(yError
                                        ,self.interfaces.errYPrevColor
                                        ,self.interfaces.vyi
                                        ,self.interfaces.cycle
                                        ,self.interfaces.kpyColor
                                        ,self.interfaces.kdyColor
                                        ,self.interfaces.kiyColor)
        self.interfaces.vyi=vyiMod
    #X Controller
    #print &quot;vx&quot;
    if(abs(xError)&lt;self.interfaces.xDistanceDeadBand):
        #print &quot;vx en banda de seguridad&quot;
        vx=0
        #self.yDeadZone=True
    else:
        #Get vx Speed thanks to the PID controller and checks if in Dead band.
        vx,vxiMod = self.interfaces.getPIDSpeed(xError
                                        ,self.interfaces.errXPrevColor
                                        ,self.interfaces.vxi
                                        ,self.interfaces.cycle
                                        ,self.interfaces.kpxColor
                                        ,self.interfaces.kdxColor
                                        ,self.interfaces.kixColor)
        self.interfaces.vxi=vxiMod
elif(areaPrimary==0 and areaSecondary&gt;0):
    #print &quot;Only Secondary&quot;
    ySecondary = momentsSecondary['m10']/momentsSecondary['m00']
    xSecondary = momentsSecondary['m01']/momentsSecondary['m00']
    yError = self.interfaces.center[1]-ySecondary
    xError = self.interfaces.center[0]-xSecondary
    #Y Controller
    #print &quot;vy&quot;
    if(abs(yError)&lt;self.interfaces.yDistanceDeadBand):
        #print &quot;Vy en banda de seguridad&quot;
        vy=0
        #self.yDeadZone=True
    else:
        #Get vy Speed thanks to the PID controller and checks if in Dead band.
        vy,vyiMod = self.interfaces.getPIDSpeed(yError
                                        ,self.interfaces.errYPrevColor
                                        ,self.interfaces.vyi
                                        ,self.interfaces.cycle
                                        ,self.interfaces.kpyColor
                                        ,self.interfaces.kdyColor
                                        ,self.interfaces.kiyColor)
        self.interfaces.vyi=vyiMod
    #X Controller
    #print &quot;vx&quot;
    if(abs(xError)&lt;self.interfaces.xDistanceDeadBand):
        #print &quot;vx en banda de seguridad&quot;
        vx=0
        #self.yDeadZone=True
    else:
        #Get vx Speed thanks to the PID controller and checks if in Dead band.
        vx,vxiMod = self.interfaces.getPIDSpeed(xError
                                        ,self.interfaces.errXPrevColor
                                        ,self.interfaces.vxi
                                        ,self.interfaces.cycle
                                        ,self.interfaces.kpxColor
                                        ,self.interfaces.kdxColor
                                        ,self.interfaces.kixColor)
        self.interfaces.vxi=vxiMod
else:
    #print &quot;Color Beacon not found&quot;
    self.interfaces.colorBeaconLost=True

#Function in order to check if the tracking is stable on the center
if (foundCenter):
    diff=time.time()-self.interfaces.stableTime
    if (self.interfaces.stableTime==0):
        self.interfaces.stableTime=time.time()
    elif (diff&lt;self.interfaces.timeLimitToLand):
        print &quot;On target for: &quot;+str(diff)+&quot; seconds&quot;
    elif (diff&gt;=self.interfaces.timeLimitToLand):
        #print &quot;Changing State&quot;
        self.interfaces.timeToLand=True		
else:
    self.interfaces.stableTime=0
#Limiting the speed prevents from overshooting as a failsafe    
vy=self.interfaces.limitSpeed(vy)
vx=self.interfaces.limitSpeed(vx)            
#Send orders to ArDrone 2                    
logging.info(&quot;vx=%.4f;&quot; % vx + &quot;vy=%.4f&quot; % vy)
self.interfaces.myCmdvel.sendCMDVel(vx,vy,0,0,0,0) 
self.interfaces.errXPrevColor=xError
self.interfaces.errYPrevColor=yError           

self.interfaces.printPerformance(start_time)

#End Takeoff</code>
      <timestep>100</timestep>
      <transition id="23">
        <type>1</type>
        <condition>return self.interfaces.colorBeaconLost</condition>
        <posx>1101.5</posx>
        <posy>1036.5</posy>
        <name>Lost</name>
        <originid>23</originid>
        <destinationid>21</destinationid>
        <code>self.interfaces.colorBeaconLost=False
self.interfaces.searchSpeed=0.01
self.interfaces.searchTrips=1</code>
      </transition>
      <transition id="24">
        <type>1</type>
        <condition>return self.interfaces.timeToLand</condition>
        <posx>1155.0</posx>
        <posy>1151.0</posy>
        <name>Stable on Color Beacon</name>
        <originid>23</originid>
        <destinationid>4</destinationid>
        <code>logging.basicConfig(filename='color2_performance',format='%(asctime)s %(message)s',level=logging.INFO)
logging.info(str(self.interfaces.minf) + &quot;;&quot; + str(self.interfaces.avgf) +&quot;;&quot; + str(self.interfaces.maxf))</code>
      </transition>
    </state>
    <state id="24" initial="True">
      <posx>1107.0</posx>
      <posy>729.0</posy>
      <name>Take off</name>
      <code>self.interfaces.myExtra.takeoff()</code>
      <timestep>100</timestep>
      <transition id="36">
        <type>0</type>
        <time>100</time>
        <posx>984.0</posx>
        <posy>731.0</posy>
        <name>Taking off</name>
        <originid>24</originid>
        <destinationid>20</destinationid>
        <code></code>
      </transition>
    </state>
  </state>
</VisualStates>
